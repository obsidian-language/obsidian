//! Sample trigonometry libary made by TheDevConnor
//! Github: https://github.com/TheDevConnor
//! License: BSD 3-Clause

fn factorial(i64 n) f64 {
    f64 res = 1.0;
    for (i64 i = 2; i <= n; i++) {
        res *= cast(i, f64);
    }
    return res;
}

fn pow(f64 x, i64 n) f64 {
    f64 res = 1.0;
    for (i64 i = 0; i < n; i++) {
        res *= x;
    }
    return res;
    // return cast(x ** cast(n, f64), f64);
}

fn abs(f64 x) f64 {
    return (x <= 0.0) ? -x : x;
}

fn degToRad(f64 deg) f64 {
    f64 PI = 3.14159265358979323846;
    return deg * PI / 180.0;
}

fn radToDeg(f64 rad) f64 {
    f64 PI = 3.14159265358979323846;
    return rad * 180.0 / PI;
}

fn sin(f64 x, i64 terms) f64 {
    f64 sin = 0.0;
    for (i64 n = 0; n < terms; n++) {
        i64 sign = ((n % 2) == 0) ? 1 : -1;
        sin += cast(sign, f64) * pow(x, 2 * n + 1) / factorial(2 * n + 1);
    }
    return sin;
}

fn csc(f64 x, i64 terms) f64 {
    return 1.0 / sin(x, terms);
}

fn arcsin(f64 x, i64 terms) f64 {
    // TODO: Fix this because of codegen error
    // Error: Mixed or unsupported operand types for binary operation
    if (x < -1.0) {
        pri64ln("Error: arcsin(x) is undefined for x < -1");
    }
    if (x > 1.0) {
        pri64ln("Error: arcsin(x) is undefined for x < -1");
    }
    f64 arsin = 0.0;
    for (i64 n = 0; n < terms; n++) {
        i64 exp = 2 * n + 1;
        arsin += (factorial(2 * n) * pow(x, exp)) / (pow(4.0, n) * pow(factorial(n), 2) * cast(exp, f64));
    }
    return arsin;
}

fn cos(f64 x, i64 terms) f64 {
    f64 cos = 0.0;
    for (i64 n = 0; n < terms; n++) {
        i64 sign = ((n % 2) == 0) ? 1 : -1; 
        cos += cast(sign, f64) * pow(x, 2 * n) / factorial(2 * n);
    }
    return cos;
}

fn sec(f64 x, i64 terms) f64 {
    return 1.0 / cos(x, terms);
}

fn arccos(f64 x, i64 terms) f64 {
    f64 PI = 3.14159265358979323846;
    return PI / 2.0 - arcsin(x, terms);
}

fn tan(f64 x, i64 terms) f64 {
    return sin(x, terms) / cos(x, terms);
}

fn cot(f64 x, i64 terms) f64 {
    return cos(x, terms) / sin(x, terms);
}

fn arctan(f64 x, i64 terms) f64 {
    f64 arctan = 0.0;
    for (i64 n = 0; n < terms; n++) {
        arctan += pow(-1.0, 2 * n + 1) * pow(x, 2 * n + 1) / cast(2 * n + 1, f64);
    }
    return arctan;
}

fn wrapAngle(f64 angle) f64 {
    f64 PI = 3.14159265358979323846;
    return angle % (2.0 * PI);
}

fn normalizeAngle(f64 angle) f64 {
    f64 x = angle;
    f64 PI = 3.14159265358979323846;
    while (x < -PI) {
        x += 2.0 * PI;
    }
    while (x > PI) {
        x -= 2.0 * PI;
    }
    return x;
}

fn main() i32 {
    pri64ln(normalizeAngle(4.0));
    pri64ln(sin(0.5, 10)); // 0.4794255386041834
    return 0;
}
